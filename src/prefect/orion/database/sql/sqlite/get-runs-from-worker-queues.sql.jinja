-- compute available slots under worker pool concurrency limits
WITH worker_slots AS (
    SELECT
        wc.id,
        MAX(0, wc.concurrency_limit - count(fr.id)) AS available_slots
    FROM
        worker_pool wc
        JOIN worker_pool_queue wq ON wq.worker_pool_id = wc.id
        LEFT JOIN flow_run fr ON wq.id = fr.worker_pool_queue_id
            AND fr.state_type in('RUNNING', 'PENDING')
    WHERE
        wc.is_paused IS FALSE
        AND wc.concurrency_limit IS NOT NULL
    GROUP BY
        wc.id
),


-- compute avaialble slots under worker pool queue concurrency limits
queue_slots AS (
    SELECT
        wq.id,
        MAX(0, wq.concurrency_limit - count(fr.id)) AS available_slots
    FROM
        worker_pool_queue wq
    LEFT JOIN flow_run fr ON wq.id = fr.worker_pool_queue_id
        AND fr.state_type in('RUNNING', 'PENDING')
WHERE
    wq.is_paused IS FALSE
    AND wq.concurrency_limit IS NOT NULL
GROUP BY
    wq.id
),


-- CTE that loads flow runs and applies worker pool queue limits
scheduled_flow_runs AS (
    SELECT
        wc.id AS run_worker_pool_id,
        wq.id AS run_worker_pool_queue_id,
        fr.*,
        worker_slots.available_slots as available_worker_slots,
        ROW_NUMBER() OVER (PARTITION BY wc.id ORDER BY {% if respect_queue_priorities %}wq.priority ASC, {% endif %}fr.next_scheduled_start_time) AS worker_pool_rank
    FROM
        worker_pool wc
        JOIN worker_pool_queue wq ON wq.worker_pool_id = wc.id
        LEFT JOIN worker_slots ON wc.id = worker_slots.id
        LEFT JOIN queue_slots ON wq.id = queue_slots.id

        JOIN (
            SELECT 
                fr.*,
                ROW_NUMBER() OVER (PARTITION BY worker_pool_queue_id ORDER BY next_scheduled_start_time) AS worker_pool_queue_rank
            FROM flow_run fr
            WHERE fr.state_type = 'SCHEDULED'
            AND fr.next_scheduled_start_time <= :scheduled_before
            ) fr
        ON 
            fr.worker_pool_queue_id = wq.id 
            AND worker_pool_queue_rank <= MIN(COALESCE(queue_slots.available_slots, :queue_limit), :queue_limit)

    WHERE
        wc.is_paused IS FALSE
        AND wq.is_paused IS FALSE
        {% if worker_pool_ids %}
        -- optionally filter for specific worker pool IDs
        AND wc.id IN :worker_pool_ids
        {% endif %}                    
        {% if worker_pool_queue_ids %}
        -- optionally filter for specific worker pool queue IDs
        AND wq.id IN :worker_pool_queue_ids
        {% endif %}
    ),

-- CTE that applies worker pool and global limits
limited_flow_runs AS (
    SELECT
        *
    FROM scheduled_flow_runs
    WHERE
        worker_pool_rank <= MIN(COALESCE(available_worker_slots, :worker_limit), :worker_limit)
    ORDER BY 
        {% if respect_queue_priorities %}
        worker_pool_rank ASC,
        {% endif %}
        next_scheduled_start_time ASC
    LIMIT :limit
)


-- sort final result by scheduled start time
SELECT * 
FROM limited_flow_runs
ORDER BY 
    next_scheduled_start_time ASC
;
# Orchestration

- no two programs are the same
    - we try to be as flexible as possible in how we govern when and how your code should execute
    - this is orchestration! the decision to run some code and adapt to what happens in a sensible and robust way

- flows and tasks are Prefect's basic unit of observability into how your code runs
- the state of flow or task run tells us everything we need to know to decide how to orchestrate a program
    - anything deeper would interfere with your flexibility to write your program the way you want
    - in "normal" operation, the description of state is straightforward: (PENDING-RUNNING-COMPLETE)
        - But of course, anything can happen!
        - It's easy to imagine that in a complex system, a flow or task will try to transition between states in all sorts of ways
        - examples?

- the job of the client is to simply try and run code--but check with orion before changing state!
    - governing this change of state (a state transition) is the domain of prefect orchestration
    - We believe all expectations of an orchestration system can happen within this abstraction
        - with all requests to change the execution state of a program centralized, the Orion instance becomes the sole source of truth:
            - current state of any run
            - global clock
            - etc
- This introduces a second responsibility of the client: knowing how to respond to Orion's instructions about how to proceed
    - because our surface area is limited to states, this is actually really intuitive:
        - everything's good to go: proceed!
        - transition to a different state instead (then proceed!)
        - the system isn't ready yet, wait
        - stop executing entirely


## Orchestration Rules

- we want to run "orchestration logic" against all state transitions that occur
- is it possible to spell out all of the core governance concepts just in terms of these transitions?
    - we think yes!
- is it possible to isolate each governance concept from eachother to create a transparent and observable orchestration engine?
    - we also think yes!

### Anatomy orchestration logic
    - the atomic unit of orchestration logic is an `OrchestrationRule` (maybe `OrchestrationUnit` / `OrchestrationTransform` or similar)
    - These must run against a state transition, because this is Orion's only opportunity to weigh in on a client trying to change the execution state of a program
    - we might want many different rules to run
        - not all of them need to run against every transition!
        - it makes sense then, that rules operate only against specific transitions for the sake of simplicity and observability

    - Orion's state DB is "the truth"
        - we can fire logic that happens just before writing to the DB, or after, and in this way orchestration concepts can be spelled out!

    - let's try defining a a concept: retries
        - retries "run" the code again if the outcome wasn't what we wanted--this is the same as Orion observing a transition into a failed state and telling the client to run again instead!
        - so before writing a "failed" state to the database, we write a "scheduled" state instead, and the client will know it needs to run the same code again sometime in the future!
    - "caching" a task that run successfully can be described similarly:
        - a state is transitioning to a completed state, so let's save it!
        - AFTER we confirm that the state has completed and is in the DB, let's also put that state in a cache table

    - what happens with multiple rules firing against the same transition?
        - we know the logic doesn't apply anymore if the transition is modified, so we need a mechanism to invalidate a rule
        - sometimes, a rule will fire but a later rule will modify the transition, we need a way to undo any side effects
            - canonical example is securing a concurrency slot, but we haven't implemented that rule yet, maybe discuss for more examples

    - because rules can run independently when structured this way, we can reason about individual features instead of needing to worry about complex interwoven orchestration logic
        - show 3 rule example where the 2nd rule rejects the transition
            - rule 1 entry: accepts
            - rule 2 entry: rejects
            - rule 3 entry: invalidated, and no logic executes
            - rule 3 exit: invalidated, and no logic executes
            - rule 2 exit: knows it rejected, does nothing
            - rule 1 exit: reverts side effects generated by rule 1 entry
        - net result: transition was rejected, and no side effects associated with the successful transition were persisted

        - we also gain observability, all rules that operate on a transition can be logged (we don't currently), and it's possible to surface exactly why prefect decided to interfere in the normal execution of a program


## Policies and observability
